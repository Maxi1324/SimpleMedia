{"ast":null,"code":"/*\n * Copyright 2018 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { __assign, __decorate, __extends } from \"tslib\";\nimport classNames from \"classnames\";\nimport * as React from \"react\";\nimport { polyfill } from \"react-lifecycles-compat\";\nimport { AbstractPureComponent2, Classes, Intent } from \"../../common\";\nimport * as Errors from \"../../common/errors\";\nimport { DISPLAYNAME_PREFIX } from \"../../common/props\";\nimport * as Utils from \"../../common/utils\";\nimport { Handle } from \"./handle\";\nimport { HandleInteractionKind, HandleType } from \"./handleProps\";\nimport { argMin, fillValues, formatPercentage } from \"./sliderUtils\";\n/**\n * SFC used to pass slider handle props to a `MultiSlider`.\n * This element is not rendered directly.\n */\n\nvar MultiSliderHandle = function () {\n  return null;\n};\n\nMultiSliderHandle.displayName = DISPLAYNAME_PREFIX + \".MultiSliderHandle\";\n\nvar MultiSlider =\n/** @class */\nfunction (_super) {\n  __extends(MultiSlider, _super);\n\n  function MultiSlider() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.state = {\n      labelPrecision: getLabelPrecision(_this.props),\n      tickSize: 0,\n      tickSizeRatio: 0\n    };\n    _this.handleElements = [];\n    _this.trackElement = null;\n\n    _this.addHandleRef = function (ref) {\n      if (ref != null) {\n        _this.handleElements.push(ref);\n      }\n    };\n\n    _this.maybeHandleTrackClick = function (event) {\n      if (_this.canHandleTrackEvent(event)) {\n        var foundHandle = _this.nearestHandleForValue(_this.handleElements, function (handle) {\n          return handle.mouseEventClientOffset(event);\n        });\n\n        if (foundHandle) {\n          foundHandle.beginHandleMovement(event);\n        }\n      }\n    };\n\n    _this.maybeHandleTrackTouch = function (event) {\n      if (_this.canHandleTrackEvent(event)) {\n        var foundHandle = _this.nearestHandleForValue(_this.handleElements, function (handle) {\n          return handle.touchEventClientOffset(event);\n        });\n\n        if (foundHandle) {\n          foundHandle.beginHandleTouchMovement(event);\n        }\n      }\n    };\n\n    _this.canHandleTrackEvent = function (event) {\n      var target = event.target; // ensure event does not come from inside the handle\n\n      return !_this.props.disabled && target.closest(\".\" + Classes.SLIDER_HANDLE) == null;\n    };\n\n    _this.getHandlerForIndex = function (index, callback) {\n      return function (newValue) {\n        callback === null || callback === void 0 ? void 0 : callback(_this.getNewHandleValues(newValue, index));\n      };\n    };\n\n    _this.handleChange = function (newValues) {\n      var _a, _b;\n\n      var handleProps = getSortedInteractiveHandleProps(_this.props);\n      var oldValues = handleProps.map(function (handle) {\n        return handle.value;\n      });\n\n      if (!Utils.arraysEqual(newValues, oldValues)) {\n        (_b = (_a = _this.props).onChange) === null || _b === void 0 ? void 0 : _b.call(_a, newValues);\n        handleProps.forEach(function (handle, index) {\n          var _a;\n\n          if (oldValues[index] !== newValues[index]) {\n            (_a = handle.onChange) === null || _a === void 0 ? void 0 : _a.call(handle, newValues[index]);\n          }\n        });\n      }\n    };\n\n    _this.handleRelease = function (newValues) {\n      var _a, _b;\n\n      var handleProps = getSortedInteractiveHandleProps(_this.props);\n      (_b = (_a = _this.props).onRelease) === null || _b === void 0 ? void 0 : _b.call(_a, newValues);\n      handleProps.forEach(function (handle, index) {\n        var _a;\n\n        (_a = handle.onRelease) === null || _a === void 0 ? void 0 : _a.call(handle, newValues[index]);\n      });\n    };\n\n    return _this;\n  }\n\n  MultiSlider_1 = MultiSlider;\n\n  MultiSlider.getDerivedStateFromProps = function (props) {\n    return {\n      labelPrecision: MultiSlider_1.getLabelPrecision(props)\n    };\n  };\n\n  MultiSlider.getLabelPrecision = function (_a) {\n    var labelPrecision = _a.labelPrecision,\n        stepSize = _a.stepSize; // infer default label precision from stepSize because that's how much the handle moves.\n\n    return labelPrecision == null ? Utils.countDecimalPlaces(stepSize) : labelPrecision;\n  };\n\n  MultiSlider.prototype.getSnapshotBeforeUpdate = function (prevProps) {\n    var prevHandleProps = getSortedInteractiveHandleProps(prevProps);\n    var newHandleProps = getSortedInteractiveHandleProps(this.props);\n\n    if (newHandleProps.length !== prevHandleProps.length) {\n      // clear refs\n      this.handleElements = [];\n    }\n\n    return null;\n  };\n\n  MultiSlider.prototype.render = function () {\n    var _a;\n\n    var _this = this;\n\n    var classes = classNames(Classes.SLIDER, (_a = {}, _a[Classes.DISABLED] = this.props.disabled, _a[Classes.SLIDER + \"-unlabeled\"] = this.props.labelRenderer === false, _a[Classes.VERTICAL] = this.props.vertical, _a), this.props.className);\n    return React.createElement(\"div\", {\n      className: classes,\n      onMouseDown: this.maybeHandleTrackClick,\n      onTouchStart: this.maybeHandleTrackTouch\n    }, React.createElement(\"div\", {\n      className: Classes.SLIDER_TRACK,\n      ref: function (ref) {\n        return _this.trackElement = ref;\n      }\n    }, this.renderTracks()), React.createElement(\"div\", {\n      className: Classes.SLIDER_AXIS\n    }, this.renderLabels()), this.renderHandles());\n  };\n\n  MultiSlider.prototype.componentDidMount = function () {\n    this.updateTickSize();\n  };\n\n  MultiSlider.prototype.componentDidUpdate = function (prevProps, prevState) {\n    _super.prototype.componentDidUpdate.call(this, prevProps, prevState);\n\n    this.updateTickSize();\n  };\n\n  MultiSlider.prototype.validateProps = function (props) {\n    if (props.stepSize <= 0) {\n      throw new Error(Errors.SLIDER_ZERO_STEP);\n    }\n\n    if (props.labelStepSize !== undefined && props.labelValues !== undefined) {\n      throw new Error(Errors.MULTISLIDER_WARN_LABEL_STEP_SIZE_LABEL_VALUES_MUTEX);\n    }\n\n    if (props.labelStepSize !== undefined && props.labelStepSize <= 0) {\n      throw new Error(Errors.SLIDER_ZERO_LABEL_STEP);\n    }\n\n    var anyInvalidChildren = false;\n    React.Children.forEach(props.children, function (child) {\n      // allow boolean coercion to omit nulls and false values\n      if (child && !Utils.isElementOfType(child, MultiSlider_1.Handle)) {\n        anyInvalidChildren = true;\n      }\n    });\n\n    if (anyInvalidChildren) {\n      throw new Error(Errors.MULTISLIDER_INVALID_CHILD);\n    }\n  };\n\n  MultiSlider.prototype.formatLabel = function (value, isHandleTooltip) {\n    if (isHandleTooltip === void 0) {\n      isHandleTooltip = false;\n    }\n\n    var labelRenderer = this.props.labelRenderer;\n\n    if (labelRenderer === false) {\n      return undefined;\n    } else if (Utils.isFunction(labelRenderer)) {\n      return labelRenderer(value, {\n        isHandleTooltip: isHandleTooltip\n      });\n    } else {\n      return value.toFixed(this.state.labelPrecision);\n    }\n  };\n\n  MultiSlider.prototype.renderLabels = function () {\n    var _this = this;\n\n    if (this.props.labelRenderer === false) {\n      return null;\n    }\n\n    var values = this.getLabelValues();\n    var _a = this.props,\n        max = _a.max,\n        min = _a.min;\n    var labels = values.map(function (step, i) {\n      var offsetPercentage = formatPercentage((step - min) / (max - min));\n      var style = _this.props.vertical ? {\n        bottom: offsetPercentage\n      } : {\n        left: offsetPercentage\n      };\n      return React.createElement(\"div\", {\n        className: Classes.SLIDER_LABEL,\n        key: i,\n        style: style\n      }, _this.formatLabel(step));\n    });\n    return labels;\n  };\n\n  MultiSlider.prototype.renderTracks = function () {\n    var trackStops = getSortedHandleProps(this.props);\n    trackStops.push({\n      value: this.props.max\n    }); // render from current to previous, then increment previous\n\n    var previous = {\n      value: this.props.min\n    };\n    var handles = [];\n\n    for (var index = 0; index < trackStops.length; index++) {\n      var current = trackStops[index];\n      handles.push(this.renderTrackFill(index, previous, current));\n      previous = current;\n    }\n\n    return handles;\n  };\n\n  MultiSlider.prototype.renderTrackFill = function (index, start, end) {\n    // ensure startRatio <= endRatio\n    var _a = [this.getOffsetRatio(start.value), this.getOffsetRatio(end.value)].sort(function (left, right) {\n      return left - right;\n    }),\n        startRatio = _a[0],\n        endRatio = _a[1];\n\n    var startOffset = formatPercentage(startRatio);\n    var endOffset = formatPercentage(1 - endRatio);\n    var orientationStyle = this.props.vertical ? {\n      bottom: startOffset,\n      top: endOffset,\n      left: 0\n    } : {\n      left: startOffset,\n      right: endOffset,\n      top: 0\n    };\n\n    var style = __assign(__assign({}, orientationStyle), start.trackStyleAfter || end.trackStyleBefore || {});\n\n    var classes = classNames(Classes.SLIDER_PROGRESS, Classes.intentClass(this.getTrackIntent(start, end)));\n    return React.createElement(\"div\", {\n      key: \"track-\" + index,\n      className: classes,\n      style: style\n    });\n  };\n\n  MultiSlider.prototype.renderHandles = function () {\n    var _this = this;\n\n    var _a = this.props,\n        disabled = _a.disabled,\n        max = _a.max,\n        min = _a.min,\n        stepSize = _a.stepSize,\n        vertical = _a.vertical;\n    var handleProps = getSortedInteractiveHandleProps(this.props);\n\n    if (handleProps.length === 0) {\n      return null;\n    }\n\n    return handleProps.map(function (_a, index) {\n      var _b;\n\n      var value = _a.value,\n          type = _a.type,\n          className = _a.className;\n      return React.createElement(Handle, {\n        className: classNames((_b = {}, _b[Classes.START] = type === HandleType.START, _b[Classes.END] = type === HandleType.END, _b), className),\n        disabled: disabled,\n        key: index + \"-\" + handleProps.length,\n        label: _this.formatLabel(value, true),\n        max: max,\n        min: min,\n        onChange: _this.getHandlerForIndex(index, _this.handleChange),\n        onRelease: _this.getHandlerForIndex(index, _this.handleRelease),\n        ref: _this.addHandleRef,\n        stepSize: stepSize,\n        tickSize: _this.state.tickSize,\n        tickSizeRatio: _this.state.tickSizeRatio,\n        value: value,\n        vertical: vertical\n      });\n    });\n  };\n\n  MultiSlider.prototype.nearestHandleForValue = function (handles, getOffset) {\n    return argMin(handles, function (handle) {\n      var offset = getOffset(handle);\n      var offsetValue = handle.clientToValue(offset);\n      var handleValue = handle.props.value;\n      return Math.abs(offsetValue - handleValue);\n    });\n  };\n\n  MultiSlider.prototype.getNewHandleValues = function (newValue, oldIndex) {\n    var handleProps = getSortedInteractiveHandleProps(this.props);\n    var oldValues = handleProps.map(function (handle) {\n      return handle.value;\n    });\n    var newValues = oldValues.slice();\n    newValues[oldIndex] = newValue;\n    newValues.sort(function (left, right) {\n      return left - right;\n    });\n    var newIndex = newValues.indexOf(newValue);\n    var lockIndex = this.findFirstLockedHandleIndex(oldIndex, newIndex);\n\n    if (lockIndex === -1) {\n      fillValues(newValues, oldIndex, newIndex, newValue);\n    } else {\n      // If pushing past a locked handle, discard the new value and only make the updates to clamp values against the lock.\n      var lockValue = oldValues[lockIndex];\n      fillValues(oldValues, oldIndex, lockIndex, lockValue);\n      return oldValues;\n    }\n\n    return newValues;\n  };\n\n  MultiSlider.prototype.findFirstLockedHandleIndex = function (startIndex, endIndex) {\n    var inc = startIndex < endIndex ? 1 : -1;\n    var handleProps = getSortedInteractiveHandleProps(this.props);\n\n    for (var index = startIndex + inc; index !== endIndex + inc; index += inc) {\n      if (handleProps[index].interactionKind !== HandleInteractionKind.PUSH) {\n        return index;\n      }\n    }\n\n    return -1;\n  };\n\n  MultiSlider.prototype.getLabelValues = function () {\n    var _a = this.props,\n        labelStepSize = _a.labelStepSize,\n        labelValues = _a.labelValues,\n        min = _a.min,\n        max = _a.max;\n    var values = [];\n\n    if (labelValues !== undefined) {\n      values = labelValues;\n    } else {\n      for (var i = min; i < max || Utils.approxEqual(i, max); i += labelStepSize !== null && labelStepSize !== void 0 ? labelStepSize : 1) {\n        values.push(i);\n      }\n    }\n\n    return values;\n  };\n\n  MultiSlider.prototype.getOffsetRatio = function (value) {\n    return Utils.clamp((value - this.props.min) * this.state.tickSizeRatio, 0, 1);\n  };\n\n  MultiSlider.prototype.getTrackIntent = function (start, end) {\n    if (!this.props.showTrackFill) {\n      return Intent.NONE;\n    }\n\n    if (start.intentAfter !== undefined) {\n      return start.intentAfter;\n    } else if (end !== undefined && end.intentBefore !== undefined) {\n      return end.intentBefore;\n    }\n\n    return this.props.defaultTrackIntent;\n  };\n\n  MultiSlider.prototype.updateTickSize = function () {\n    if (this.trackElement != null) {\n      var trackSize = this.props.vertical ? this.trackElement.clientHeight : this.trackElement.clientWidth;\n      var tickSizeRatio = 1 / (this.props.max - this.props.min);\n      var tickSize = trackSize * tickSizeRatio;\n      this.setState({\n        tickSize: tickSize,\n        tickSizeRatio: tickSizeRatio\n      });\n    }\n  };\n\n  var MultiSlider_1;\n  MultiSlider.defaultSliderProps = {\n    disabled: false,\n    max: 10,\n    min: 0,\n    showTrackFill: true,\n    stepSize: 1,\n    vertical: false\n  };\n  MultiSlider.defaultProps = __assign(__assign({}, MultiSlider_1.defaultSliderProps), {\n    defaultTrackIntent: Intent.NONE\n  });\n  MultiSlider.displayName = DISPLAYNAME_PREFIX + \".MultiSlider\";\n  MultiSlider.Handle = MultiSliderHandle;\n  MultiSlider = MultiSlider_1 = __decorate([polyfill], MultiSlider);\n  return MultiSlider;\n}(AbstractPureComponent2);\n\nexport { MultiSlider };\n\nfunction getLabelPrecision(_a) {\n  var labelPrecision = _a.labelPrecision,\n      _b = _a.stepSize,\n      stepSize = _b === void 0 ? MultiSlider.defaultSliderProps.stepSize : _b; // infer default label precision from stepSize because that's how much the handle moves.\n\n  return labelPrecision == null ? Utils.countDecimalPlaces(stepSize) : labelPrecision;\n}\n\nfunction getSortedInteractiveHandleProps(props) {\n  return getSortedHandleProps(props, function (childProps) {\n    return childProps.interactionKind !== HandleInteractionKind.NONE;\n  });\n}\n\nfunction getSortedHandleProps(_a, predicate) {\n  var children = _a.children;\n\n  if (predicate === void 0) {\n    predicate = function () {\n      return true;\n    };\n  }\n\n  var maybeHandles = React.Children.map(children, function (child) {\n    return Utils.isElementOfType(child, MultiSlider.Handle) && predicate(child.props) ? child.props : null;\n  });\n  var handles = maybeHandles != null ? maybeHandles : [];\n  handles = handles.filter(function (handle) {\n    return handle !== null;\n  });\n  handles.sort(function (left, right) {\n    return left.value - right.value;\n  });\n  return handles;\n}","map":{"version":3,"sources":["../../../../src/components/slider/multiSlider.tsx"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/*\n * Copyright 2018 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { __assign, __decorate, __extends } from \"tslib\";\nimport classNames from \"classnames\";\nimport * as React from \"react\";\nimport { polyfill } from \"react-lifecycles-compat\";\nimport { AbstractPureComponent2, Classes, Intent } from \"../../common\";\nimport * as Errors from \"../../common/errors\";\nimport { DISPLAYNAME_PREFIX } from \"../../common/props\";\nimport * as Utils from \"../../common/utils\";\nimport { Handle } from \"./handle\";\nimport { HandleInteractionKind, HandleType } from \"./handleProps\";\nimport { argMin, fillValues, formatPercentage } from \"./sliderUtils\";\n/**\n * SFC used to pass slider handle props to a `MultiSlider`.\n * This element is not rendered directly.\n */\nvar MultiSliderHandle = function () { return null; };\nMultiSliderHandle.displayName = DISPLAYNAME_PREFIX + \".MultiSliderHandle\";\nvar MultiSlider = /** @class */ (function (_super) {\n    __extends(MultiSlider, _super);\n    function MultiSlider() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.state = {\n            labelPrecision: getLabelPrecision(_this.props),\n            tickSize: 0,\n            tickSizeRatio: 0,\n        };\n        _this.handleElements = [];\n        _this.trackElement = null;\n        _this.addHandleRef = function (ref) {\n            if (ref != null) {\n                _this.handleElements.push(ref);\n            }\n        };\n        _this.maybeHandleTrackClick = function (event) {\n            if (_this.canHandleTrackEvent(event)) {\n                var foundHandle = _this.nearestHandleForValue(_this.handleElements, function (handle) {\n                    return handle.mouseEventClientOffset(event);\n                });\n                if (foundHandle) {\n                    foundHandle.beginHandleMovement(event);\n                }\n            }\n        };\n        _this.maybeHandleTrackTouch = function (event) {\n            if (_this.canHandleTrackEvent(event)) {\n                var foundHandle = _this.nearestHandleForValue(_this.handleElements, function (handle) {\n                    return handle.touchEventClientOffset(event);\n                });\n                if (foundHandle) {\n                    foundHandle.beginHandleTouchMovement(event);\n                }\n            }\n        };\n        _this.canHandleTrackEvent = function (event) {\n            var target = event.target;\n            // ensure event does not come from inside the handle\n            return !_this.props.disabled && target.closest(\".\" + Classes.SLIDER_HANDLE) == null;\n        };\n        _this.getHandlerForIndex = function (index, callback) {\n            return function (newValue) {\n                callback === null || callback === void 0 ? void 0 : callback(_this.getNewHandleValues(newValue, index));\n            };\n        };\n        _this.handleChange = function (newValues) {\n            var _a, _b;\n            var handleProps = getSortedInteractiveHandleProps(_this.props);\n            var oldValues = handleProps.map(function (handle) { return handle.value; });\n            if (!Utils.arraysEqual(newValues, oldValues)) {\n                (_b = (_a = _this.props).onChange) === null || _b === void 0 ? void 0 : _b.call(_a, newValues);\n                handleProps.forEach(function (handle, index) {\n                    var _a;\n                    if (oldValues[index] !== newValues[index]) {\n                        (_a = handle.onChange) === null || _a === void 0 ? void 0 : _a.call(handle, newValues[index]);\n                    }\n                });\n            }\n        };\n        _this.handleRelease = function (newValues) {\n            var _a, _b;\n            var handleProps = getSortedInteractiveHandleProps(_this.props);\n            (_b = (_a = _this.props).onRelease) === null || _b === void 0 ? void 0 : _b.call(_a, newValues);\n            handleProps.forEach(function (handle, index) {\n                var _a;\n                (_a = handle.onRelease) === null || _a === void 0 ? void 0 : _a.call(handle, newValues[index]);\n            });\n        };\n        return _this;\n    }\n    MultiSlider_1 = MultiSlider;\n    MultiSlider.getDerivedStateFromProps = function (props) {\n        return { labelPrecision: MultiSlider_1.getLabelPrecision(props) };\n    };\n    MultiSlider.getLabelPrecision = function (_a) {\n        var labelPrecision = _a.labelPrecision, stepSize = _a.stepSize;\n        // infer default label precision from stepSize because that's how much the handle moves.\n        return labelPrecision == null ? Utils.countDecimalPlaces(stepSize) : labelPrecision;\n    };\n    MultiSlider.prototype.getSnapshotBeforeUpdate = function (prevProps) {\n        var prevHandleProps = getSortedInteractiveHandleProps(prevProps);\n        var newHandleProps = getSortedInteractiveHandleProps(this.props);\n        if (newHandleProps.length !== prevHandleProps.length) {\n            // clear refs\n            this.handleElements = [];\n        }\n        return null;\n    };\n    MultiSlider.prototype.render = function () {\n        var _a;\n        var _this = this;\n        var classes = classNames(Classes.SLIDER, (_a = {},\n            _a[Classes.DISABLED] = this.props.disabled,\n            _a[Classes.SLIDER + \"-unlabeled\"] = this.props.labelRenderer === false,\n            _a[Classes.VERTICAL] = this.props.vertical,\n            _a), this.props.className);\n        return (React.createElement(\"div\", { className: classes, onMouseDown: this.maybeHandleTrackClick, onTouchStart: this.maybeHandleTrackTouch },\n            React.createElement(\"div\", { className: Classes.SLIDER_TRACK, ref: function (ref) { return (_this.trackElement = ref); } }, this.renderTracks()),\n            React.createElement(\"div\", { className: Classes.SLIDER_AXIS }, this.renderLabels()),\n            this.renderHandles()));\n    };\n    MultiSlider.prototype.componentDidMount = function () {\n        this.updateTickSize();\n    };\n    MultiSlider.prototype.componentDidUpdate = function (prevProps, prevState) {\n        _super.prototype.componentDidUpdate.call(this, prevProps, prevState);\n        this.updateTickSize();\n    };\n    MultiSlider.prototype.validateProps = function (props) {\n        if (props.stepSize <= 0) {\n            throw new Error(Errors.SLIDER_ZERO_STEP);\n        }\n        if (props.labelStepSize !== undefined && props.labelValues !== undefined) {\n            throw new Error(Errors.MULTISLIDER_WARN_LABEL_STEP_SIZE_LABEL_VALUES_MUTEX);\n        }\n        if (props.labelStepSize !== undefined && props.labelStepSize <= 0) {\n            throw new Error(Errors.SLIDER_ZERO_LABEL_STEP);\n        }\n        var anyInvalidChildren = false;\n        React.Children.forEach(props.children, function (child) {\n            // allow boolean coercion to omit nulls and false values\n            if (child && !Utils.isElementOfType(child, MultiSlider_1.Handle)) {\n                anyInvalidChildren = true;\n            }\n        });\n        if (anyInvalidChildren) {\n            throw new Error(Errors.MULTISLIDER_INVALID_CHILD);\n        }\n    };\n    MultiSlider.prototype.formatLabel = function (value, isHandleTooltip) {\n        if (isHandleTooltip === void 0) { isHandleTooltip = false; }\n        var labelRenderer = this.props.labelRenderer;\n        if (labelRenderer === false) {\n            return undefined;\n        }\n        else if (Utils.isFunction(labelRenderer)) {\n            return labelRenderer(value, { isHandleTooltip: isHandleTooltip });\n        }\n        else {\n            return value.toFixed(this.state.labelPrecision);\n        }\n    };\n    MultiSlider.prototype.renderLabels = function () {\n        var _this = this;\n        if (this.props.labelRenderer === false) {\n            return null;\n        }\n        var values = this.getLabelValues();\n        var _a = this.props, max = _a.max, min = _a.min;\n        var labels = values.map(function (step, i) {\n            var offsetPercentage = formatPercentage((step - min) / (max - min));\n            var style = _this.props.vertical ? { bottom: offsetPercentage } : { left: offsetPercentage };\n            return (React.createElement(\"div\", { className: Classes.SLIDER_LABEL, key: i, style: style }, _this.formatLabel(step)));\n        });\n        return labels;\n    };\n    MultiSlider.prototype.renderTracks = function () {\n        var trackStops = getSortedHandleProps(this.props);\n        trackStops.push({ value: this.props.max });\n        // render from current to previous, then increment previous\n        var previous = { value: this.props.min };\n        var handles = [];\n        for (var index = 0; index < trackStops.length; index++) {\n            var current = trackStops[index];\n            handles.push(this.renderTrackFill(index, previous, current));\n            previous = current;\n        }\n        return handles;\n    };\n    MultiSlider.prototype.renderTrackFill = function (index, start, end) {\n        // ensure startRatio <= endRatio\n        var _a = [this.getOffsetRatio(start.value), this.getOffsetRatio(end.value)].sort(function (left, right) { return left - right; }), startRatio = _a[0], endRatio = _a[1];\n        var startOffset = formatPercentage(startRatio);\n        var endOffset = formatPercentage(1 - endRatio);\n        var orientationStyle = this.props.vertical\n            ? { bottom: startOffset, top: endOffset, left: 0 }\n            : { left: startOffset, right: endOffset, top: 0 };\n        var style = __assign(__assign({}, orientationStyle), (start.trackStyleAfter || end.trackStyleBefore || {}));\n        var classes = classNames(Classes.SLIDER_PROGRESS, Classes.intentClass(this.getTrackIntent(start, end)));\n        return React.createElement(\"div\", { key: \"track-\" + index, className: classes, style: style });\n    };\n    MultiSlider.prototype.renderHandles = function () {\n        var _this = this;\n        var _a = this.props, disabled = _a.disabled, max = _a.max, min = _a.min, stepSize = _a.stepSize, vertical = _a.vertical;\n        var handleProps = getSortedInteractiveHandleProps(this.props);\n        if (handleProps.length === 0) {\n            return null;\n        }\n        return handleProps.map(function (_a, index) {\n            var _b;\n            var value = _a.value, type = _a.type, className = _a.className;\n            return (React.createElement(Handle, { className: classNames((_b = {},\n                    _b[Classes.START] = type === HandleType.START,\n                    _b[Classes.END] = type === HandleType.END,\n                    _b), className), disabled: disabled, key: index + \"-\" + handleProps.length, label: _this.formatLabel(value, true), max: max, min: min, onChange: _this.getHandlerForIndex(index, _this.handleChange), onRelease: _this.getHandlerForIndex(index, _this.handleRelease), ref: _this.addHandleRef, stepSize: stepSize, tickSize: _this.state.tickSize, tickSizeRatio: _this.state.tickSizeRatio, value: value, vertical: vertical }));\n        });\n    };\n    MultiSlider.prototype.nearestHandleForValue = function (handles, getOffset) {\n        return argMin(handles, function (handle) {\n            var offset = getOffset(handle);\n            var offsetValue = handle.clientToValue(offset);\n            var handleValue = handle.props.value;\n            return Math.abs(offsetValue - handleValue);\n        });\n    };\n    MultiSlider.prototype.getNewHandleValues = function (newValue, oldIndex) {\n        var handleProps = getSortedInteractiveHandleProps(this.props);\n        var oldValues = handleProps.map(function (handle) { return handle.value; });\n        var newValues = oldValues.slice();\n        newValues[oldIndex] = newValue;\n        newValues.sort(function (left, right) { return left - right; });\n        var newIndex = newValues.indexOf(newValue);\n        var lockIndex = this.findFirstLockedHandleIndex(oldIndex, newIndex);\n        if (lockIndex === -1) {\n            fillValues(newValues, oldIndex, newIndex, newValue);\n        }\n        else {\n            // If pushing past a locked handle, discard the new value and only make the updates to clamp values against the lock.\n            var lockValue = oldValues[lockIndex];\n            fillValues(oldValues, oldIndex, lockIndex, lockValue);\n            return oldValues;\n        }\n        return newValues;\n    };\n    MultiSlider.prototype.findFirstLockedHandleIndex = function (startIndex, endIndex) {\n        var inc = startIndex < endIndex ? 1 : -1;\n        var handleProps = getSortedInteractiveHandleProps(this.props);\n        for (var index = startIndex + inc; index !== endIndex + inc; index += inc) {\n            if (handleProps[index].interactionKind !== HandleInteractionKind.PUSH) {\n                return index;\n            }\n        }\n        return -1;\n    };\n    MultiSlider.prototype.getLabelValues = function () {\n        var _a = this.props, labelStepSize = _a.labelStepSize, labelValues = _a.labelValues, min = _a.min, max = _a.max;\n        var values = [];\n        if (labelValues !== undefined) {\n            values = labelValues;\n        }\n        else {\n            for (var i = min; i < max || Utils.approxEqual(i, max); i += labelStepSize !== null && labelStepSize !== void 0 ? labelStepSize : 1) {\n                values.push(i);\n            }\n        }\n        return values;\n    };\n    MultiSlider.prototype.getOffsetRatio = function (value) {\n        return Utils.clamp((value - this.props.min) * this.state.tickSizeRatio, 0, 1);\n    };\n    MultiSlider.prototype.getTrackIntent = function (start, end) {\n        if (!this.props.showTrackFill) {\n            return Intent.NONE;\n        }\n        if (start.intentAfter !== undefined) {\n            return start.intentAfter;\n        }\n        else if (end !== undefined && end.intentBefore !== undefined) {\n            return end.intentBefore;\n        }\n        return this.props.defaultTrackIntent;\n    };\n    MultiSlider.prototype.updateTickSize = function () {\n        if (this.trackElement != null) {\n            var trackSize = this.props.vertical ? this.trackElement.clientHeight : this.trackElement.clientWidth;\n            var tickSizeRatio = 1 / (this.props.max - this.props.min);\n            var tickSize = trackSize * tickSizeRatio;\n            this.setState({ tickSize: tickSize, tickSizeRatio: tickSizeRatio });\n        }\n    };\n    var MultiSlider_1;\n    MultiSlider.defaultSliderProps = {\n        disabled: false,\n        max: 10,\n        min: 0,\n        showTrackFill: true,\n        stepSize: 1,\n        vertical: false,\n    };\n    MultiSlider.defaultProps = __assign(__assign({}, MultiSlider_1.defaultSliderProps), { defaultTrackIntent: Intent.NONE });\n    MultiSlider.displayName = DISPLAYNAME_PREFIX + \".MultiSlider\";\n    MultiSlider.Handle = MultiSliderHandle;\n    MultiSlider = MultiSlider_1 = __decorate([\n        polyfill\n    ], MultiSlider);\n    return MultiSlider;\n}(AbstractPureComponent2));\nexport { MultiSlider };\nfunction getLabelPrecision(_a) {\n    var labelPrecision = _a.labelPrecision, _b = _a.stepSize, stepSize = _b === void 0 ? MultiSlider.defaultSliderProps.stepSize : _b;\n    // infer default label precision from stepSize because that's how much the handle moves.\n    return labelPrecision == null ? Utils.countDecimalPlaces(stepSize) : labelPrecision;\n}\nfunction getSortedInteractiveHandleProps(props) {\n    return getSortedHandleProps(props, function (childProps) { return childProps.interactionKind !== HandleInteractionKind.NONE; });\n}\nfunction getSortedHandleProps(_a, predicate) {\n    var children = _a.children;\n    if (predicate === void 0) { predicate = function () { return true; }; }\n    var maybeHandles = React.Children.map(children, function (child) {\n        return Utils.isElementOfType(child, MultiSlider.Handle) && predicate(child.props) ? child.props : null;\n    });\n    var handles = maybeHandles != null ? maybeHandles : [];\n    handles = handles.filter(function (handle) { return handle !== null; });\n    handles.sort(function (left, right) { return left.value - right.value; });\n    return handles;\n}\n//# sourceMappingURL=multiSlider.js.map"]},"metadata":{},"sourceType":"module"}