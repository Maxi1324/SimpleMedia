{"ast":null,"code":"/*\n * Copyright 2015 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { __assign, __decorate, __extends } from \"tslib\";\nimport classNames from \"classnames\";\nimport * as React from \"react\";\nimport { polyfill } from \"react-lifecycles-compat\";\nimport { AbstractPureComponent2, Classes, Keys } from \"../../common\";\nimport { DISPLAYNAME_PREFIX } from \"../../common/props\";\nimport * as Utils from \"../../common/utils\";\nimport { Tab } from \"./tab\";\nimport { generateTabPanelId, generateTabTitleId, TabTitle } from \"./tabTitle\";\nexport var Expander = function () {\n  return React.createElement(\"div\", {\n    className: Classes.FLEX_EXPANDER\n  });\n};\nvar TAB_SELECTOR = \".\" + Classes.TAB; // HACKHACK: https://github.com/palantir/blueprint/issues/4342\n\nvar Tabs =\n/** @class */\nfunction (_super) {\n  __extends(Tabs, _super);\n\n  function Tabs(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this.tablistElement = null;\n    _this.refHandlers = {\n      tablist: function (tabElement) {\n        return _this.tablistElement = tabElement;\n      }\n    };\n\n    _this.handleKeyDown = function (e) {\n      var _a;\n\n      var focusedElement = (_a = document.activeElement) === null || _a === void 0 ? void 0 : _a.closest(TAB_SELECTOR); // rest of this is potentially expensive and futile, so bail if no tab is focused\n\n      if (focusedElement == null) {\n        return;\n      } // must rely on DOM state because we have no way of mapping `focusedElement` to a JSX.Element\n\n\n      var enabledTabElements = _this.getTabElements().filter(function (el) {\n        return el.getAttribute(\"aria-disabled\") === \"false\";\n      });\n\n      var focusedIndex = enabledTabElements.indexOf(focusedElement);\n\n      var direction = _this.getKeyCodeDirection(e);\n\n      if (focusedIndex >= 0 && direction !== undefined) {\n        e.preventDefault();\n        var length_1 = enabledTabElements.length; // auto-wrapping at 0 and `length`\n\n        var nextFocusedIndex = (focusedIndex + direction + length_1) % length_1;\n        enabledTabElements[nextFocusedIndex].focus();\n      }\n    };\n\n    _this.handleKeyPress = function (e) {\n      var targetTabElement = e.target.closest(TAB_SELECTOR); // HACKHACK: https://github.com/palantir/blueprint/issues/4165\n      // eslint-disable-next-line deprecation/deprecation\n\n      if (targetTabElement != null && Keys.isKeyboardClick(e.which)) {\n        e.preventDefault();\n        targetTabElement.click();\n      }\n    };\n\n    _this.handleTabClick = function (newTabId, event) {\n      var _a, _b;\n\n      (_b = (_a = _this.props).onChange) === null || _b === void 0 ? void 0 : _b.call(_a, newTabId, _this.state.selectedTabId, event);\n\n      if (_this.props.selectedTabId === undefined) {\n        _this.setState({\n          selectedTabId: newTabId\n        });\n      }\n    };\n\n    _this.renderTabPanel = function (tab) {\n      var _a = tab.props,\n          className = _a.className,\n          panel = _a.panel,\n          id = _a.id,\n          panelClassName = _a.panelClassName;\n\n      if (panel === undefined) {\n        return undefined;\n      }\n\n      return React.createElement(\"div\", {\n        \"aria-labelledby\": generateTabTitleId(_this.props.id, id),\n        \"aria-hidden\": id !== _this.state.selectedTabId,\n        className: classNames(Classes.TAB_PANEL, className, panelClassName),\n        id: generateTabPanelId(_this.props.id, id),\n        key: id,\n        role: \"tabpanel\"\n      }, panel);\n    };\n\n    _this.renderTabTitle = function (child) {\n      if (isTabElement(child)) {\n        var id = child.props.id;\n        return React.createElement(TabTitle, __assign({}, child.props, {\n          parentId: _this.props.id,\n          onClick: _this.handleTabClick,\n          selected: id === _this.state.selectedTabId\n        }));\n      }\n\n      return child;\n    };\n\n    var selectedTabId = _this.getInitialSelectedTabId();\n\n    _this.state = {\n      selectedTabId: selectedTabId\n    };\n    return _this;\n  }\n\n  Tabs.getDerivedStateFromProps = function (_a) {\n    var selectedTabId = _a.selectedTabId;\n\n    if (selectedTabId !== undefined) {\n      // keep state in sync with controlled prop, so state is canonical source of truth\n      return {\n        selectedTabId: selectedTabId\n      };\n    }\n\n    return null;\n  };\n\n  Tabs.prototype.render = function () {\n    var _a, _b;\n\n    var _c = this.state,\n        indicatorWrapperStyle = _c.indicatorWrapperStyle,\n        selectedTabId = _c.selectedTabId;\n    var tabTitles = React.Children.map(this.props.children, this.renderTabTitle);\n    var tabPanels = this.getTabChildren().filter(this.props.renderActiveTabPanelOnly ? function (tab) {\n      return tab.props.id === selectedTabId;\n    } : function () {\n      return true;\n    }).map(this.renderTabPanel);\n    var tabIndicator = this.props.animate ? React.createElement(\"div\", {\n      className: Classes.TAB_INDICATOR_WRAPPER,\n      style: indicatorWrapperStyle\n    }, React.createElement(\"div\", {\n      className: Classes.TAB_INDICATOR\n    })) : null;\n    var classes = classNames(Classes.TABS, (_a = {}, _a[Classes.VERTICAL] = this.props.vertical, _a), this.props.className);\n    var tabListClasses = classNames(Classes.TAB_LIST, (_b = {}, _b[Classes.LARGE] = this.props.large, _b));\n    return React.createElement(\"div\", {\n      className: classes\n    }, React.createElement(\"div\", {\n      className: tabListClasses,\n      onKeyDown: this.handleKeyDown,\n      onKeyPress: this.handleKeyPress,\n      ref: this.refHandlers.tablist,\n      role: \"tablist\"\n    }, tabIndicator, tabTitles), tabPanels);\n  };\n\n  Tabs.prototype.componentDidMount = function () {\n    this.moveSelectionIndicator(false);\n  };\n\n  Tabs.prototype.componentDidUpdate = function (prevProps, prevState) {\n    if (this.state.selectedTabId !== prevState.selectedTabId) {\n      this.moveSelectionIndicator();\n    } else if (prevState.selectedTabId != null) {\n      // comparing React nodes is difficult to do with simple logic, so\n      // shallowly compare just their props as a workaround.\n      var didChildrenChange = !Utils.arraysEqual(this.getTabChildrenProps(prevProps), this.getTabChildrenProps(), Utils.shallowCompareKeys);\n\n      if (didChildrenChange) {\n        this.moveSelectionIndicator();\n      }\n    }\n  };\n\n  Tabs.prototype.getInitialSelectedTabId = function () {\n    // NOTE: providing an unknown ID will hide the selection\n    var _a = this.props,\n        defaultSelectedTabId = _a.defaultSelectedTabId,\n        selectedTabId = _a.selectedTabId;\n\n    if (selectedTabId !== undefined) {\n      return selectedTabId;\n    } else if (defaultSelectedTabId !== undefined) {\n      return defaultSelectedTabId;\n    } else {\n      // select first tab in absence of user input\n      var tabs = this.getTabChildren();\n      return tabs.length === 0 ? undefined : tabs[0].props.id;\n    }\n  };\n\n  Tabs.prototype.getKeyCodeDirection = function (e) {\n    if (isEventKeyCode(e, Keys.ARROW_LEFT, Keys.ARROW_UP)) {\n      return -1;\n    } else if (isEventKeyCode(e, Keys.ARROW_RIGHT, Keys.ARROW_DOWN)) {\n      return 1;\n    }\n\n    return undefined;\n  };\n\n  Tabs.prototype.getTabChildrenProps = function (props) {\n    if (props === void 0) {\n      props = this.props;\n    }\n\n    return this.getTabChildren(props).map(function (child) {\n      return child.props;\n    });\n  };\n  /** Filters children to only `<Tab>`s */\n\n\n  Tabs.prototype.getTabChildren = function (props) {\n    if (props === void 0) {\n      props = this.props;\n    }\n\n    return React.Children.toArray(props.children).filter(isTabElement);\n  };\n  /** Queries root HTML element for all tabs with optional filter selector */\n\n\n  Tabs.prototype.getTabElements = function (subselector) {\n    if (subselector === void 0) {\n      subselector = \"\";\n    }\n\n    if (this.tablistElement == null) {\n      return [];\n    }\n\n    return Array.from(this.tablistElement.querySelectorAll(TAB_SELECTOR + subselector));\n  };\n  /**\n   * Calculate the new height, width, and position of the tab indicator.\n   * Store the CSS values so the transition animation can start.\n   */\n\n\n  Tabs.prototype.moveSelectionIndicator = function (animate) {\n    if (animate === void 0) {\n      animate = true;\n    }\n\n    if (this.tablistElement == null || !this.props.animate) {\n      return;\n    }\n\n    var tabIdSelector = TAB_SELECTOR + \"[data-tab-id=\\\"\" + this.state.selectedTabId + \"\\\"]\";\n    var selectedTabElement = this.tablistElement.querySelector(tabIdSelector);\n    var indicatorWrapperStyle = {\n      display: \"none\"\n    };\n\n    if (selectedTabElement != null) {\n      var clientHeight = selectedTabElement.clientHeight,\n          clientWidth = selectedTabElement.clientWidth,\n          offsetLeft = selectedTabElement.offsetLeft,\n          offsetTop = selectedTabElement.offsetTop;\n      indicatorWrapperStyle = {\n        height: clientHeight,\n        transform: \"translateX(\" + Math.floor(offsetLeft) + \"px) translateY(\" + Math.floor(offsetTop) + \"px)\",\n        width: clientWidth\n      };\n\n      if (!animate) {\n        indicatorWrapperStyle.transition = \"none\";\n      }\n    }\n\n    this.setState({\n      indicatorWrapperStyle: indicatorWrapperStyle\n    });\n  };\n  /** Insert a `Tabs.Expander` between any two children to right-align all subsequent children. */\n\n\n  Tabs.Expander = Expander;\n  Tabs.Tab = Tab;\n  Tabs.defaultProps = {\n    animate: true,\n    large: false,\n    renderActiveTabPanelOnly: false,\n    vertical: false\n  };\n  Tabs.displayName = DISPLAYNAME_PREFIX + \".Tabs\";\n  Tabs = __decorate([polyfill], Tabs);\n  return Tabs;\n}(AbstractPureComponent2);\n\nexport { Tabs };\n\nfunction isEventKeyCode(e) {\n  var codes = [];\n\n  for (var _i = 1; _i < arguments.length; _i++) {\n    codes[_i - 1] = arguments[_i];\n  } // HACKHACK: https://github.com/palantir/blueprint/issues/4165\n  // eslint-disable-next-line deprecation/deprecation\n\n\n  return codes.indexOf(e.which) >= 0;\n}\n\nfunction isTabElement(child) {\n  return Utils.isElementOfType(child, Tab);\n}","map":{"version":3,"sources":["../../../../src/components/tabs/tabs.tsx"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/*\n * Copyright 2015 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { __assign, __decorate, __extends } from \"tslib\";\nimport classNames from \"classnames\";\nimport * as React from \"react\";\nimport { polyfill } from \"react-lifecycles-compat\";\nimport { AbstractPureComponent2, Classes, Keys } from \"../../common\";\nimport { DISPLAYNAME_PREFIX } from \"../../common/props\";\nimport * as Utils from \"../../common/utils\";\nimport { Tab } from \"./tab\";\nimport { generateTabPanelId, generateTabTitleId, TabTitle } from \"./tabTitle\";\nexport var Expander = function () { return React.createElement(\"div\", { className: Classes.FLEX_EXPANDER }); };\nvar TAB_SELECTOR = \".\" + Classes.TAB;\n// HACKHACK: https://github.com/palantir/blueprint/issues/4342\nvar Tabs = /** @class */ (function (_super) {\n    __extends(Tabs, _super);\n    function Tabs(props) {\n        var _this = _super.call(this, props) || this;\n        _this.tablistElement = null;\n        _this.refHandlers = {\n            tablist: function (tabElement) { return (_this.tablistElement = tabElement); },\n        };\n        _this.handleKeyDown = function (e) {\n            var _a;\n            var focusedElement = (_a = document.activeElement) === null || _a === void 0 ? void 0 : _a.closest(TAB_SELECTOR);\n            // rest of this is potentially expensive and futile, so bail if no tab is focused\n            if (focusedElement == null) {\n                return;\n            }\n            // must rely on DOM state because we have no way of mapping `focusedElement` to a JSX.Element\n            var enabledTabElements = _this.getTabElements().filter(function (el) { return el.getAttribute(\"aria-disabled\") === \"false\"; });\n            var focusedIndex = enabledTabElements.indexOf(focusedElement);\n            var direction = _this.getKeyCodeDirection(e);\n            if (focusedIndex >= 0 && direction !== undefined) {\n                e.preventDefault();\n                var length_1 = enabledTabElements.length;\n                // auto-wrapping at 0 and `length`\n                var nextFocusedIndex = (focusedIndex + direction + length_1) % length_1;\n                enabledTabElements[nextFocusedIndex].focus();\n            }\n        };\n        _this.handleKeyPress = function (e) {\n            var targetTabElement = e.target.closest(TAB_SELECTOR);\n            // HACKHACK: https://github.com/palantir/blueprint/issues/4165\n            // eslint-disable-next-line deprecation/deprecation\n            if (targetTabElement != null && Keys.isKeyboardClick(e.which)) {\n                e.preventDefault();\n                targetTabElement.click();\n            }\n        };\n        _this.handleTabClick = function (newTabId, event) {\n            var _a, _b;\n            (_b = (_a = _this.props).onChange) === null || _b === void 0 ? void 0 : _b.call(_a, newTabId, _this.state.selectedTabId, event);\n            if (_this.props.selectedTabId === undefined) {\n                _this.setState({ selectedTabId: newTabId });\n            }\n        };\n        _this.renderTabPanel = function (tab) {\n            var _a = tab.props, className = _a.className, panel = _a.panel, id = _a.id, panelClassName = _a.panelClassName;\n            if (panel === undefined) {\n                return undefined;\n            }\n            return (React.createElement(\"div\", { \"aria-labelledby\": generateTabTitleId(_this.props.id, id), \"aria-hidden\": id !== _this.state.selectedTabId, className: classNames(Classes.TAB_PANEL, className, panelClassName), id: generateTabPanelId(_this.props.id, id), key: id, role: \"tabpanel\" }, panel));\n        };\n        _this.renderTabTitle = function (child) {\n            if (isTabElement(child)) {\n                var id = child.props.id;\n                return (React.createElement(TabTitle, __assign({}, child.props, { parentId: _this.props.id, onClick: _this.handleTabClick, selected: id === _this.state.selectedTabId })));\n            }\n            return child;\n        };\n        var selectedTabId = _this.getInitialSelectedTabId();\n        _this.state = { selectedTabId: selectedTabId };\n        return _this;\n    }\n    Tabs.getDerivedStateFromProps = function (_a) {\n        var selectedTabId = _a.selectedTabId;\n        if (selectedTabId !== undefined) {\n            // keep state in sync with controlled prop, so state is canonical source of truth\n            return { selectedTabId: selectedTabId };\n        }\n        return null;\n    };\n    Tabs.prototype.render = function () {\n        var _a, _b;\n        var _c = this.state, indicatorWrapperStyle = _c.indicatorWrapperStyle, selectedTabId = _c.selectedTabId;\n        var tabTitles = React.Children.map(this.props.children, this.renderTabTitle);\n        var tabPanels = this.getTabChildren()\n            .filter(this.props.renderActiveTabPanelOnly ? function (tab) { return tab.props.id === selectedTabId; } : function () { return true; })\n            .map(this.renderTabPanel);\n        var tabIndicator = this.props.animate ? (React.createElement(\"div\", { className: Classes.TAB_INDICATOR_WRAPPER, style: indicatorWrapperStyle },\n            React.createElement(\"div\", { className: Classes.TAB_INDICATOR }))) : null;\n        var classes = classNames(Classes.TABS, (_a = {}, _a[Classes.VERTICAL] = this.props.vertical, _a), this.props.className);\n        var tabListClasses = classNames(Classes.TAB_LIST, (_b = {},\n            _b[Classes.LARGE] = this.props.large,\n            _b));\n        return (React.createElement(\"div\", { className: classes },\n            React.createElement(\"div\", { className: tabListClasses, onKeyDown: this.handleKeyDown, onKeyPress: this.handleKeyPress, ref: this.refHandlers.tablist, role: \"tablist\" },\n                tabIndicator,\n                tabTitles),\n            tabPanels));\n    };\n    Tabs.prototype.componentDidMount = function () {\n        this.moveSelectionIndicator(false);\n    };\n    Tabs.prototype.componentDidUpdate = function (prevProps, prevState) {\n        if (this.state.selectedTabId !== prevState.selectedTabId) {\n            this.moveSelectionIndicator();\n        }\n        else if (prevState.selectedTabId != null) {\n            // comparing React nodes is difficult to do with simple logic, so\n            // shallowly compare just their props as a workaround.\n            var didChildrenChange = !Utils.arraysEqual(this.getTabChildrenProps(prevProps), this.getTabChildrenProps(), Utils.shallowCompareKeys);\n            if (didChildrenChange) {\n                this.moveSelectionIndicator();\n            }\n        }\n    };\n    Tabs.prototype.getInitialSelectedTabId = function () {\n        // NOTE: providing an unknown ID will hide the selection\n        var _a = this.props, defaultSelectedTabId = _a.defaultSelectedTabId, selectedTabId = _a.selectedTabId;\n        if (selectedTabId !== undefined) {\n            return selectedTabId;\n        }\n        else if (defaultSelectedTabId !== undefined) {\n            return defaultSelectedTabId;\n        }\n        else {\n            // select first tab in absence of user input\n            var tabs = this.getTabChildren();\n            return tabs.length === 0 ? undefined : tabs[0].props.id;\n        }\n    };\n    Tabs.prototype.getKeyCodeDirection = function (e) {\n        if (isEventKeyCode(e, Keys.ARROW_LEFT, Keys.ARROW_UP)) {\n            return -1;\n        }\n        else if (isEventKeyCode(e, Keys.ARROW_RIGHT, Keys.ARROW_DOWN)) {\n            return 1;\n        }\n        return undefined;\n    };\n    Tabs.prototype.getTabChildrenProps = function (props) {\n        if (props === void 0) { props = this.props; }\n        return this.getTabChildren(props).map(function (child) { return child.props; });\n    };\n    /** Filters children to only `<Tab>`s */\n    Tabs.prototype.getTabChildren = function (props) {\n        if (props === void 0) { props = this.props; }\n        return React.Children.toArray(props.children).filter(isTabElement);\n    };\n    /** Queries root HTML element for all tabs with optional filter selector */\n    Tabs.prototype.getTabElements = function (subselector) {\n        if (subselector === void 0) { subselector = \"\"; }\n        if (this.tablistElement == null) {\n            return [];\n        }\n        return Array.from(this.tablistElement.querySelectorAll(TAB_SELECTOR + subselector));\n    };\n    /**\n     * Calculate the new height, width, and position of the tab indicator.\n     * Store the CSS values so the transition animation can start.\n     */\n    Tabs.prototype.moveSelectionIndicator = function (animate) {\n        if (animate === void 0) { animate = true; }\n        if (this.tablistElement == null || !this.props.animate) {\n            return;\n        }\n        var tabIdSelector = TAB_SELECTOR + \"[data-tab-id=\\\"\" + this.state.selectedTabId + \"\\\"]\";\n        var selectedTabElement = this.tablistElement.querySelector(tabIdSelector);\n        var indicatorWrapperStyle = { display: \"none\" };\n        if (selectedTabElement != null) {\n            var clientHeight = selectedTabElement.clientHeight, clientWidth = selectedTabElement.clientWidth, offsetLeft = selectedTabElement.offsetLeft, offsetTop = selectedTabElement.offsetTop;\n            indicatorWrapperStyle = {\n                height: clientHeight,\n                transform: \"translateX(\" + Math.floor(offsetLeft) + \"px) translateY(\" + Math.floor(offsetTop) + \"px)\",\n                width: clientWidth,\n            };\n            if (!animate) {\n                indicatorWrapperStyle.transition = \"none\";\n            }\n        }\n        this.setState({ indicatorWrapperStyle: indicatorWrapperStyle });\n    };\n    /** Insert a `Tabs.Expander` between any two children to right-align all subsequent children. */\n    Tabs.Expander = Expander;\n    Tabs.Tab = Tab;\n    Tabs.defaultProps = {\n        animate: true,\n        large: false,\n        renderActiveTabPanelOnly: false,\n        vertical: false,\n    };\n    Tabs.displayName = DISPLAYNAME_PREFIX + \".Tabs\";\n    Tabs = __decorate([\n        polyfill\n    ], Tabs);\n    return Tabs;\n}(AbstractPureComponent2));\nexport { Tabs };\nfunction isEventKeyCode(e) {\n    var codes = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        codes[_i - 1] = arguments[_i];\n    }\n    // HACKHACK: https://github.com/palantir/blueprint/issues/4165\n    // eslint-disable-next-line deprecation/deprecation\n    return codes.indexOf(e.which) >= 0;\n}\nfunction isTabElement(child) {\n    return Utils.isElementOfType(child, Tab);\n}\n//# sourceMappingURL=tabs.js.map"]},"metadata":{},"sourceType":"module"}