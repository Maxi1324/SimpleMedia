{"ast":null,"code":"/*\n * Copyright 2016 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { __decorate, __extends } from \"tslib\";\nimport classNames from \"classnames\";\nimport * as React from \"react\";\nimport { polyfill } from \"react-lifecycles-compat\";\nimport { AbstractPureComponent2, Classes, Keys } from \"../../common\";\nimport { DISPLAYNAME_PREFIX } from \"../../common/props\";\nimport { clamp } from \"../../common/utils\";\nimport { formatPercentage } from \"./sliderUtils\"; // props that require number values, for validation\n\nvar NUMBER_PROPS = [\"max\", \"min\", \"stepSize\", \"tickSize\", \"value\"];\n/** Internal component for a Handle with click/drag/keyboard logic to determine a new value. */\n\nvar Handle =\n/** @class */\nfunction (_super) {\n  __extends(Handle, _super);\n\n  function Handle() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.state = {\n      isMoving: false\n    };\n    _this.handleElement = null;\n    _this.refHandlers = {\n      handle: function (el) {\n        return _this.handleElement = el;\n      }\n    };\n\n    _this.beginHandleMovement = function (event) {\n      document.addEventListener(\"mousemove\", _this.handleHandleMovement);\n      document.addEventListener(\"mouseup\", _this.endHandleMovement);\n\n      _this.setState({\n        isMoving: true\n      });\n\n      _this.changeValue(_this.clientToValue(_this.mouseEventClientOffset(event)));\n    };\n\n    _this.beginHandleTouchMovement = function (event) {\n      document.addEventListener(\"touchmove\", _this.handleHandleTouchMovement);\n      document.addEventListener(\"touchend\", _this.endHandleTouchMovement);\n      document.addEventListener(\"touchcancel\", _this.endHandleTouchMovement);\n\n      _this.setState({\n        isMoving: true\n      });\n\n      _this.changeValue(_this.clientToValue(_this.touchEventClientOffset(event)));\n    };\n\n    _this.getStyleProperties = function () {\n      if (_this.handleElement == null) {\n        return {};\n      } // The handle midpoint of RangeSlider is actually shifted by a margin to\n      // be on the edge of the visible handle element. Because the midpoint\n      // calculation does not take this margin into account, we instead\n      // measure the long side (which is equal to the short side plus the\n      // margin).\n\n\n      var _a = _this.props,\n          _b = _a.min,\n          min = _b === void 0 ? 0 : _b,\n          tickSizeRatio = _a.tickSizeRatio,\n          value = _a.value,\n          vertical = _a.vertical;\n\n      var handleMidpoint = _this.getHandleMidpointAndOffset(_this.handleElement, true).handleMidpoint;\n\n      var offsetRatio = (value - min) * tickSizeRatio;\n      var offsetCalc = \"calc(\" + formatPercentage(offsetRatio) + \" - \" + handleMidpoint + \"px)\";\n      return vertical ? {\n        bottom: offsetCalc\n      } : {\n        left: offsetCalc\n      };\n    };\n\n    _this.endHandleMovement = function (event) {\n      _this.handleMoveEndedAt(_this.mouseEventClientOffset(event));\n    };\n\n    _this.endHandleTouchMovement = function (event) {\n      _this.handleMoveEndedAt(_this.touchEventClientOffset(event));\n    };\n\n    _this.handleMoveEndedAt = function (clientPixel) {\n      var _a, _b;\n\n      _this.removeDocumentEventListeners();\n\n      _this.setState({\n        isMoving: false\n      }); // always invoke onRelease; changeValue may call onChange if value is different\n\n\n      var finalValue = _this.changeValue(_this.clientToValue(clientPixel));\n\n      (_b = (_a = _this.props).onRelease) === null || _b === void 0 ? void 0 : _b.call(_a, finalValue);\n    };\n\n    _this.handleHandleMovement = function (event) {\n      _this.handleMovedTo(_this.mouseEventClientOffset(event));\n    };\n\n    _this.handleHandleTouchMovement = function (event) {\n      _this.handleMovedTo(_this.touchEventClientOffset(event));\n    };\n\n    _this.handleMovedTo = function (clientPixel) {\n      if (_this.state.isMoving && !_this.props.disabled) {\n        _this.changeValue(_this.clientToValue(clientPixel));\n      }\n    };\n\n    _this.handleKeyDown = function (event) {\n      var _a = _this.props,\n          stepSize = _a.stepSize,\n          value = _a.value; // HACKHACK: https://github.com/palantir/blueprint/issues/4165\n\n      /* eslint-disable-next-line deprecation/deprecation */\n\n      var which = event.which;\n\n      if (which === Keys.ARROW_DOWN || which === Keys.ARROW_LEFT) {\n        _this.changeValue(value - stepSize); // this key event has been handled! prevent browser scroll on up/down\n\n\n        event.preventDefault();\n      } else if (which === Keys.ARROW_UP || which === Keys.ARROW_RIGHT) {\n        _this.changeValue(value + stepSize);\n\n        event.preventDefault();\n      }\n    };\n\n    _this.handleKeyUp = function (event) {\n      var _a, _b; // HACKHACK: https://github.com/palantir/blueprint/issues/4165\n\n      /* eslint-disable-next-line deprecation/deprecation */\n\n\n      if ([Keys.ARROW_UP, Keys.ARROW_DOWN, Keys.ARROW_LEFT, Keys.ARROW_RIGHT].indexOf(event.which) >= 0) {\n        (_b = (_a = _this.props).onRelease) === null || _b === void 0 ? void 0 : _b.call(_a, _this.props.value);\n      }\n    };\n\n    return _this;\n  }\n\n  Handle.prototype.componentDidMount = function () {\n    // The first time this component renders, it has no ref to the handle and thus incorrectly centers the handle.\n    // Therefore, on the first mount, force a re-render to center the handle with the ref'd component.\n    this.forceUpdate();\n  };\n\n  Handle.prototype.render = function () {\n    var _a;\n\n    var _b = this.props,\n        className = _b.className,\n        disabled = _b.disabled,\n        label = _b.label;\n    var isMoving = this.state.isMoving;\n    return React.createElement(\"span\", {\n      className: classNames(Classes.SLIDER_HANDLE, (_a = {}, _a[Classes.ACTIVE] = isMoving, _a), className),\n      onKeyDown: disabled ? undefined : this.handleKeyDown,\n      onKeyUp: disabled ? undefined : this.handleKeyUp,\n      onMouseDown: disabled ? undefined : this.beginHandleMovement,\n      onTouchStart: disabled ? undefined : this.beginHandleTouchMovement,\n      ref: this.refHandlers.handle,\n      style: this.getStyleProperties(),\n      tabIndex: 0\n    }, label == null ? null : React.createElement(\"span\", {\n      className: Classes.SLIDER_LABEL\n    }, label));\n  };\n\n  Handle.prototype.componentWillUnmount = function () {\n    this.removeDocumentEventListeners();\n  };\n  /** Convert client pixel to value between min and max. */\n\n\n  Handle.prototype.clientToValue = function (clientPixel) {\n    var _a = this.props,\n        stepSize = _a.stepSize,\n        tickSize = _a.tickSize,\n        value = _a.value,\n        vertical = _a.vertical;\n\n    if (this.handleElement == null) {\n      return value;\n    } // #1769: this logic doesn't work perfectly when the tick size is\n    // smaller than the handle size; it may be off by a tick or two.\n\n\n    var clientPixelNormalized = vertical ? window.innerHeight - clientPixel : clientPixel;\n    var handleCenterPixel = this.getHandleElementCenterPixel(this.handleElement);\n    var pixelDelta = clientPixelNormalized - handleCenterPixel;\n\n    if (isNaN(pixelDelta)) {\n      return value;\n    } // convert pixels to range value in increments of `stepSize`\n\n\n    return value + Math.round(pixelDelta / (tickSize * stepSize)) * stepSize;\n  };\n\n  Handle.prototype.mouseEventClientOffset = function (event) {\n    return this.props.vertical ? event.clientY : event.clientX;\n  };\n\n  Handle.prototype.touchEventClientOffset = function (event) {\n    var touch = event.changedTouches[0];\n    return this.props.vertical ? touch.clientY : touch.clientX;\n  };\n\n  Handle.prototype.validateProps = function (props) {\n    for (var _i = 0, NUMBER_PROPS_1 = NUMBER_PROPS; _i < NUMBER_PROPS_1.length; _i++) {\n      var prop = NUMBER_PROPS_1[_i];\n\n      if (typeof props[prop] !== \"number\") {\n        throw new Error(\"[Blueprint] <Handle> requires number value for \" + prop + \" prop\");\n      }\n    }\n  };\n  /** Clamp value and invoke callback if it differs from current value */\n\n\n  Handle.prototype.changeValue = function (newValue, callback) {\n    if (callback === void 0) {\n      callback = this.props.onChange;\n    }\n\n    newValue = this.clamp(newValue);\n\n    if (!isNaN(newValue) && this.props.value !== newValue) {\n      callback === null || callback === void 0 ? void 0 : callback(newValue);\n    }\n\n    return newValue;\n  };\n  /** Clamp value between min and max props */\n\n\n  Handle.prototype.clamp = function (value) {\n    return clamp(value, this.props.min, this.props.max);\n  };\n\n  Handle.prototype.getHandleElementCenterPixel = function (handleElement) {\n    var _a = this.getHandleMidpointAndOffset(handleElement),\n        handleMidpoint = _a.handleMidpoint,\n        handleOffset = _a.handleOffset;\n\n    return handleOffset + handleMidpoint;\n  };\n\n  Handle.prototype.getHandleMidpointAndOffset = function (handleElement, useOppositeDimension) {\n    if (useOppositeDimension === void 0) {\n      useOppositeDimension = false;\n    }\n\n    if (handleElement == null) {\n      return {\n        handleMidpoint: 0,\n        handleOffset: 0\n      };\n    }\n\n    var vertical = this.props.vertical; // getBoundingClientRect().height includes border size; clientHeight does not.\n\n    var handleRect = handleElement.getBoundingClientRect();\n    var sizeKey = vertical ? useOppositeDimension ? \"width\" : \"height\" : useOppositeDimension ? \"height\" : \"width\"; // \"bottom\" value seems to be consistently incorrect, so explicitly\n    // calculate it using the window offset instead.\n\n    var handleOffset = vertical ? window.innerHeight - (handleRect.top + handleRect[sizeKey]) : handleRect.left;\n    return {\n      handleMidpoint: handleRect[sizeKey] / 2,\n      handleOffset: handleOffset\n    };\n  };\n\n  Handle.prototype.removeDocumentEventListeners = function () {\n    document.removeEventListener(\"mousemove\", this.handleHandleMovement);\n    document.removeEventListener(\"mouseup\", this.endHandleMovement);\n    document.removeEventListener(\"touchmove\", this.handleHandleTouchMovement);\n    document.removeEventListener(\"touchend\", this.endHandleTouchMovement);\n    document.removeEventListener(\"touchcancel\", this.endHandleTouchMovement);\n  };\n\n  Handle.displayName = DISPLAYNAME_PREFIX + \".SliderHandle\";\n  Handle = __decorate([polyfill], Handle);\n  return Handle;\n}(AbstractPureComponent2);\n\nexport { Handle };","map":{"version":3,"sources":["../../../../src/components/slider/handle.tsx"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/*\n * Copyright 2016 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { __decorate, __extends } from \"tslib\";\nimport classNames from \"classnames\";\nimport * as React from \"react\";\nimport { polyfill } from \"react-lifecycles-compat\";\nimport { AbstractPureComponent2, Classes, Keys } from \"../../common\";\nimport { DISPLAYNAME_PREFIX } from \"../../common/props\";\nimport { clamp } from \"../../common/utils\";\nimport { formatPercentage } from \"./sliderUtils\";\n// props that require number values, for validation\nvar NUMBER_PROPS = [\"max\", \"min\", \"stepSize\", \"tickSize\", \"value\"];\n/** Internal component for a Handle with click/drag/keyboard logic to determine a new value. */\nvar Handle = /** @class */ (function (_super) {\n    __extends(Handle, _super);\n    function Handle() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.state = {\n            isMoving: false,\n        };\n        _this.handleElement = null;\n        _this.refHandlers = {\n            handle: function (el) { return (_this.handleElement = el); },\n        };\n        _this.beginHandleMovement = function (event) {\n            document.addEventListener(\"mousemove\", _this.handleHandleMovement);\n            document.addEventListener(\"mouseup\", _this.endHandleMovement);\n            _this.setState({ isMoving: true });\n            _this.changeValue(_this.clientToValue(_this.mouseEventClientOffset(event)));\n        };\n        _this.beginHandleTouchMovement = function (event) {\n            document.addEventListener(\"touchmove\", _this.handleHandleTouchMovement);\n            document.addEventListener(\"touchend\", _this.endHandleTouchMovement);\n            document.addEventListener(\"touchcancel\", _this.endHandleTouchMovement);\n            _this.setState({ isMoving: true });\n            _this.changeValue(_this.clientToValue(_this.touchEventClientOffset(event)));\n        };\n        _this.getStyleProperties = function () {\n            if (_this.handleElement == null) {\n                return {};\n            }\n            // The handle midpoint of RangeSlider is actually shifted by a margin to\n            // be on the edge of the visible handle element. Because the midpoint\n            // calculation does not take this margin into account, we instead\n            // measure the long side (which is equal to the short side plus the\n            // margin).\n            var _a = _this.props, _b = _a.min, min = _b === void 0 ? 0 : _b, tickSizeRatio = _a.tickSizeRatio, value = _a.value, vertical = _a.vertical;\n            var handleMidpoint = _this.getHandleMidpointAndOffset(_this.handleElement, true).handleMidpoint;\n            var offsetRatio = (value - min) * tickSizeRatio;\n            var offsetCalc = \"calc(\" + formatPercentage(offsetRatio) + \" - \" + handleMidpoint + \"px)\";\n            return vertical ? { bottom: offsetCalc } : { left: offsetCalc };\n        };\n        _this.endHandleMovement = function (event) {\n            _this.handleMoveEndedAt(_this.mouseEventClientOffset(event));\n        };\n        _this.endHandleTouchMovement = function (event) {\n            _this.handleMoveEndedAt(_this.touchEventClientOffset(event));\n        };\n        _this.handleMoveEndedAt = function (clientPixel) {\n            var _a, _b;\n            _this.removeDocumentEventListeners();\n            _this.setState({ isMoving: false });\n            // always invoke onRelease; changeValue may call onChange if value is different\n            var finalValue = _this.changeValue(_this.clientToValue(clientPixel));\n            (_b = (_a = _this.props).onRelease) === null || _b === void 0 ? void 0 : _b.call(_a, finalValue);\n        };\n        _this.handleHandleMovement = function (event) {\n            _this.handleMovedTo(_this.mouseEventClientOffset(event));\n        };\n        _this.handleHandleTouchMovement = function (event) {\n            _this.handleMovedTo(_this.touchEventClientOffset(event));\n        };\n        _this.handleMovedTo = function (clientPixel) {\n            if (_this.state.isMoving && !_this.props.disabled) {\n                _this.changeValue(_this.clientToValue(clientPixel));\n            }\n        };\n        _this.handleKeyDown = function (event) {\n            var _a = _this.props, stepSize = _a.stepSize, value = _a.value;\n            // HACKHACK: https://github.com/palantir/blueprint/issues/4165\n            /* eslint-disable-next-line deprecation/deprecation */\n            var which = event.which;\n            if (which === Keys.ARROW_DOWN || which === Keys.ARROW_LEFT) {\n                _this.changeValue(value - stepSize);\n                // this key event has been handled! prevent browser scroll on up/down\n                event.preventDefault();\n            }\n            else if (which === Keys.ARROW_UP || which === Keys.ARROW_RIGHT) {\n                _this.changeValue(value + stepSize);\n                event.preventDefault();\n            }\n        };\n        _this.handleKeyUp = function (event) {\n            var _a, _b;\n            // HACKHACK: https://github.com/palantir/blueprint/issues/4165\n            /* eslint-disable-next-line deprecation/deprecation */\n            if ([Keys.ARROW_UP, Keys.ARROW_DOWN, Keys.ARROW_LEFT, Keys.ARROW_RIGHT].indexOf(event.which) >= 0) {\n                (_b = (_a = _this.props).onRelease) === null || _b === void 0 ? void 0 : _b.call(_a, _this.props.value);\n            }\n        };\n        return _this;\n    }\n    Handle.prototype.componentDidMount = function () {\n        // The first time this component renders, it has no ref to the handle and thus incorrectly centers the handle.\n        // Therefore, on the first mount, force a re-render to center the handle with the ref'd component.\n        this.forceUpdate();\n    };\n    Handle.prototype.render = function () {\n        var _a;\n        var _b = this.props, className = _b.className, disabled = _b.disabled, label = _b.label;\n        var isMoving = this.state.isMoving;\n        return (React.createElement(\"span\", { className: classNames(Classes.SLIDER_HANDLE, (_a = {}, _a[Classes.ACTIVE] = isMoving, _a), className), onKeyDown: disabled ? undefined : this.handleKeyDown, onKeyUp: disabled ? undefined : this.handleKeyUp, onMouseDown: disabled ? undefined : this.beginHandleMovement, onTouchStart: disabled ? undefined : this.beginHandleTouchMovement, ref: this.refHandlers.handle, style: this.getStyleProperties(), tabIndex: 0 }, label == null ? null : React.createElement(\"span\", { className: Classes.SLIDER_LABEL }, label)));\n    };\n    Handle.prototype.componentWillUnmount = function () {\n        this.removeDocumentEventListeners();\n    };\n    /** Convert client pixel to value between min and max. */\n    Handle.prototype.clientToValue = function (clientPixel) {\n        var _a = this.props, stepSize = _a.stepSize, tickSize = _a.tickSize, value = _a.value, vertical = _a.vertical;\n        if (this.handleElement == null) {\n            return value;\n        }\n        // #1769: this logic doesn't work perfectly when the tick size is\n        // smaller than the handle size; it may be off by a tick or two.\n        var clientPixelNormalized = vertical ? window.innerHeight - clientPixel : clientPixel;\n        var handleCenterPixel = this.getHandleElementCenterPixel(this.handleElement);\n        var pixelDelta = clientPixelNormalized - handleCenterPixel;\n        if (isNaN(pixelDelta)) {\n            return value;\n        }\n        // convert pixels to range value in increments of `stepSize`\n        return value + Math.round(pixelDelta / (tickSize * stepSize)) * stepSize;\n    };\n    Handle.prototype.mouseEventClientOffset = function (event) {\n        return this.props.vertical ? event.clientY : event.clientX;\n    };\n    Handle.prototype.touchEventClientOffset = function (event) {\n        var touch = event.changedTouches[0];\n        return this.props.vertical ? touch.clientY : touch.clientX;\n    };\n    Handle.prototype.validateProps = function (props) {\n        for (var _i = 0, NUMBER_PROPS_1 = NUMBER_PROPS; _i < NUMBER_PROPS_1.length; _i++) {\n            var prop = NUMBER_PROPS_1[_i];\n            if (typeof props[prop] !== \"number\") {\n                throw new Error(\"[Blueprint] <Handle> requires number value for \" + prop + \" prop\");\n            }\n        }\n    };\n    /** Clamp value and invoke callback if it differs from current value */\n    Handle.prototype.changeValue = function (newValue, callback) {\n        if (callback === void 0) { callback = this.props.onChange; }\n        newValue = this.clamp(newValue);\n        if (!isNaN(newValue) && this.props.value !== newValue) {\n            callback === null || callback === void 0 ? void 0 : callback(newValue);\n        }\n        return newValue;\n    };\n    /** Clamp value between min and max props */\n    Handle.prototype.clamp = function (value) {\n        return clamp(value, this.props.min, this.props.max);\n    };\n    Handle.prototype.getHandleElementCenterPixel = function (handleElement) {\n        var _a = this.getHandleMidpointAndOffset(handleElement), handleMidpoint = _a.handleMidpoint, handleOffset = _a.handleOffset;\n        return handleOffset + handleMidpoint;\n    };\n    Handle.prototype.getHandleMidpointAndOffset = function (handleElement, useOppositeDimension) {\n        if (useOppositeDimension === void 0) { useOppositeDimension = false; }\n        if (handleElement == null) {\n            return { handleMidpoint: 0, handleOffset: 0 };\n        }\n        var vertical = this.props.vertical;\n        // getBoundingClientRect().height includes border size; clientHeight does not.\n        var handleRect = handleElement.getBoundingClientRect();\n        var sizeKey = vertical\n            ? useOppositeDimension\n                ? \"width\"\n                : \"height\"\n            : useOppositeDimension\n                ? \"height\"\n                : \"width\";\n        // \"bottom\" value seems to be consistently incorrect, so explicitly\n        // calculate it using the window offset instead.\n        var handleOffset = vertical ? window.innerHeight - (handleRect.top + handleRect[sizeKey]) : handleRect.left;\n        return { handleMidpoint: handleRect[sizeKey] / 2, handleOffset: handleOffset };\n    };\n    Handle.prototype.removeDocumentEventListeners = function () {\n        document.removeEventListener(\"mousemove\", this.handleHandleMovement);\n        document.removeEventListener(\"mouseup\", this.endHandleMovement);\n        document.removeEventListener(\"touchmove\", this.handleHandleTouchMovement);\n        document.removeEventListener(\"touchend\", this.endHandleTouchMovement);\n        document.removeEventListener(\"touchcancel\", this.endHandleTouchMovement);\n    };\n    Handle.displayName = DISPLAYNAME_PREFIX + \".SliderHandle\";\n    Handle = __decorate([\n        polyfill\n    ], Handle);\n    return Handle;\n}(AbstractPureComponent2));\nexport { Handle };\n//# sourceMappingURL=handle.js.map"]},"metadata":{},"sourceType":"module"}