{"ast":null,"code":"/*\n * Copyright 2018 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { __extends, __spreadArrays } from \"tslib\";\nimport classNames from \"classnames\";\nimport * as React from \"react\";\nimport { Boundary } from \"../../common/boundary\";\nimport * as Classes from \"../../common/classes\";\nimport { OVERFLOW_LIST_OBSERVE_PARENTS_CHANGED } from \"../../common/errors\";\nimport { DISPLAYNAME_PREFIX } from \"../../common/props\";\nimport { shallowCompareKeys } from \"../../common/utils\";\nimport { ResizeSensor } from \"../resize-sensor/resizeSensor\";\n/** @internal - do not expose this type */\n\nexport var OverflowDirection;\n\n(function (OverflowDirection) {\n  OverflowDirection[OverflowDirection[\"NONE\"] = 0] = \"NONE\";\n  OverflowDirection[OverflowDirection[\"GROW\"] = 1] = \"GROW\";\n  OverflowDirection[OverflowDirection[\"SHRINK\"] = 2] = \"SHRINK\";\n})(OverflowDirection || (OverflowDirection = {}));\n\nvar OverflowList =\n/** @class */\nfunction (_super) {\n  __extends(OverflowList, _super);\n\n  function OverflowList() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.state = {\n      direction: OverflowDirection.NONE,\n      lastOverflowCount: 0,\n      overflow: [],\n      visible: _this.props.items\n    };\n    /** A cache containing the widths of all elements being observed to detect growing/shrinking */\n\n    _this.previousWidths = new Map();\n    _this.spacer = null;\n\n    _this.resize = function (entries) {\n      // if any parent is growing, assume we have more room than before\n      var growing = entries.some(function (entry) {\n        var previousWidth = _this.previousWidths.get(entry.target) || 0;\n        return entry.contentRect.width > previousWidth;\n      });\n\n      _this.repartition(growing);\n\n      entries.forEach(function (entry) {\n        return _this.previousWidths.set(entry.target, entry.contentRect.width);\n      });\n    };\n\n    return _this;\n  }\n\n  OverflowList.ofType = function () {\n    return OverflowList;\n  };\n\n  OverflowList.prototype.componentDidMount = function () {\n    this.repartition(false);\n  };\n\n  OverflowList.prototype.shouldComponentUpdate = function (_nextProps, nextState) {\n    // We want this component to always re-render, even when props haven't changed, so that\n    // changes in the renderers' behavior can be reflected.\n    // The following statement prevents re-rendering only in the case where the state changes\n    // identity (i.e. setState was called), but the state is still the same when\n    // shallow-compared to the previous state.\n    return !(this.state !== nextState && shallowCompareKeys(this.state, nextState));\n  };\n\n  OverflowList.prototype.componentDidUpdate = function (prevProps, prevState) {\n    var _a, _b;\n\n    if (prevProps.observeParents !== this.props.observeParents) {\n      console.warn(OVERFLOW_LIST_OBSERVE_PARENTS_CHANGED);\n    }\n\n    if (prevProps.collapseFrom !== this.props.collapseFrom || prevProps.items !== this.props.items || prevProps.minVisibleItems !== this.props.minVisibleItems || prevProps.overflowRenderer !== this.props.overflowRenderer || prevProps.visibleItemRenderer !== this.props.visibleItemRenderer) {\n      // reset visible state if the above props change.\n      this.setState({\n        direction: OverflowDirection.GROW,\n        lastOverflowCount: 0,\n        overflow: [],\n        visible: this.props.items\n      });\n    }\n\n    if (!shallowCompareKeys(prevState, this.state)) {\n      this.repartition(false);\n    }\n\n    var _c = this.state,\n        direction = _c.direction,\n        overflow = _c.overflow,\n        lastOverflowCount = _c.lastOverflowCount;\n\n    if ( // if a resize operation has just completed (transition to NONE)\n    direction === OverflowDirection.NONE && direction !== prevState.direction && overflow.length !== lastOverflowCount) {\n      (_b = (_a = this.props).onOverflow) === null || _b === void 0 ? void 0 : _b.call(_a, overflow);\n    }\n  };\n\n  OverflowList.prototype.render = function () {\n    var _this = this;\n\n    var _a = this.props,\n        className = _a.className,\n        collapseFrom = _a.collapseFrom,\n        observeParents = _a.observeParents,\n        style = _a.style,\n        _b = _a.tagName,\n        tagName = _b === void 0 ? \"div\" : _b,\n        visibleItemRenderer = _a.visibleItemRenderer;\n    var overflow = this.maybeRenderOverflow();\n    var list = React.createElement(tagName, {\n      className: classNames(Classes.OVERFLOW_LIST, className),\n      style: style\n    }, collapseFrom === Boundary.START ? overflow : null, this.state.visible.map(visibleItemRenderer), collapseFrom === Boundary.END ? overflow : null, React.createElement(\"div\", {\n      className: Classes.OVERFLOW_LIST_SPACER,\n      ref: function (ref) {\n        return _this.spacer = ref;\n      }\n    }));\n    return React.createElement(ResizeSensor, {\n      onResize: this.resize,\n      observeParents: observeParents\n    }, list);\n  };\n\n  OverflowList.prototype.maybeRenderOverflow = function () {\n    var overflow = this.state.overflow;\n\n    if (overflow.length === 0) {\n      return null;\n    }\n\n    return this.props.overflowRenderer(overflow);\n  };\n\n  OverflowList.prototype.repartition = function (growing) {\n    var _this = this;\n\n    if (this.spacer == null) {\n      return;\n    }\n\n    if (growing) {\n      this.setState(function (state) {\n        return {\n          direction: OverflowDirection.GROW,\n          // store last overflow if this is the beginning of a resize (for check in componentDidUpdate).\n          lastOverflowCount: state.direction === OverflowDirection.NONE ? state.overflow.length : state.lastOverflowCount,\n          overflow: [],\n          visible: _this.props.items\n        };\n      });\n    } else if (this.spacer.getBoundingClientRect().width < 0.9) {\n      // spacer has flex-shrink and width 1px so if it's much smaller then we know to shrink\n      this.setState(function (state) {\n        if (state.visible.length <= _this.props.minVisibleItems) {\n          return null;\n        }\n\n        var collapseFromStart = _this.props.collapseFrom === Boundary.START;\n        var visible = state.visible.slice();\n        var next = collapseFromStart ? visible.shift() : visible.pop();\n\n        if (next === undefined) {\n          return null;\n        }\n\n        var overflow = collapseFromStart ? __spreadArrays(state.overflow, [next]) : __spreadArrays([next], state.overflow);\n        return {\n          // set SHRINK mode unless a GROW is already in progress.\n          // GROW shows all items then shrinks until it settles, so we\n          // preserve the fact that the original trigger was a GROW.\n          direction: state.direction === OverflowDirection.NONE ? OverflowDirection.SHRINK : state.direction,\n          overflow: overflow,\n          visible: visible\n        };\n      });\n    } else {\n      // repartition complete!\n      this.setState({\n        direction: OverflowDirection.NONE\n      });\n    }\n  };\n\n  OverflowList.displayName = DISPLAYNAME_PREFIX + \".OverflowList\";\n  OverflowList.defaultProps = {\n    collapseFrom: Boundary.START,\n    minVisibleItems: 0\n  };\n  return OverflowList;\n}(React.Component);\n\nexport { OverflowList };","map":{"version":3,"sources":["../../../../src/components/overflow-list/overflowList.tsx"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/*\n * Copyright 2018 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { __extends, __spreadArrays } from \"tslib\";\nimport classNames from \"classnames\";\nimport * as React from \"react\";\nimport { Boundary } from \"../../common/boundary\";\nimport * as Classes from \"../../common/classes\";\nimport { OVERFLOW_LIST_OBSERVE_PARENTS_CHANGED } from \"../../common/errors\";\nimport { DISPLAYNAME_PREFIX } from \"../../common/props\";\nimport { shallowCompareKeys } from \"../../common/utils\";\nimport { ResizeSensor } from \"../resize-sensor/resizeSensor\";\n/** @internal - do not expose this type */\nexport var OverflowDirection;\n(function (OverflowDirection) {\n    OverflowDirection[OverflowDirection[\"NONE\"] = 0] = \"NONE\";\n    OverflowDirection[OverflowDirection[\"GROW\"] = 1] = \"GROW\";\n    OverflowDirection[OverflowDirection[\"SHRINK\"] = 2] = \"SHRINK\";\n})(OverflowDirection || (OverflowDirection = {}));\nvar OverflowList = /** @class */ (function (_super) {\n    __extends(OverflowList, _super);\n    function OverflowList() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.state = {\n            direction: OverflowDirection.NONE,\n            lastOverflowCount: 0,\n            overflow: [],\n            visible: _this.props.items,\n        };\n        /** A cache containing the widths of all elements being observed to detect growing/shrinking */\n        _this.previousWidths = new Map();\n        _this.spacer = null;\n        _this.resize = function (entries) {\n            // if any parent is growing, assume we have more room than before\n            var growing = entries.some(function (entry) {\n                var previousWidth = _this.previousWidths.get(entry.target) || 0;\n                return entry.contentRect.width > previousWidth;\n            });\n            _this.repartition(growing);\n            entries.forEach(function (entry) { return _this.previousWidths.set(entry.target, entry.contentRect.width); });\n        };\n        return _this;\n    }\n    OverflowList.ofType = function () {\n        return OverflowList;\n    };\n    OverflowList.prototype.componentDidMount = function () {\n        this.repartition(false);\n    };\n    OverflowList.prototype.shouldComponentUpdate = function (_nextProps, nextState) {\n        // We want this component to always re-render, even when props haven't changed, so that\n        // changes in the renderers' behavior can be reflected.\n        // The following statement prevents re-rendering only in the case where the state changes\n        // identity (i.e. setState was called), but the state is still the same when\n        // shallow-compared to the previous state.\n        return !(this.state !== nextState && shallowCompareKeys(this.state, nextState));\n    };\n    OverflowList.prototype.componentDidUpdate = function (prevProps, prevState) {\n        var _a, _b;\n        if (prevProps.observeParents !== this.props.observeParents) {\n            console.warn(OVERFLOW_LIST_OBSERVE_PARENTS_CHANGED);\n        }\n        if (prevProps.collapseFrom !== this.props.collapseFrom ||\n            prevProps.items !== this.props.items ||\n            prevProps.minVisibleItems !== this.props.minVisibleItems ||\n            prevProps.overflowRenderer !== this.props.overflowRenderer ||\n            prevProps.visibleItemRenderer !== this.props.visibleItemRenderer) {\n            // reset visible state if the above props change.\n            this.setState({\n                direction: OverflowDirection.GROW,\n                lastOverflowCount: 0,\n                overflow: [],\n                visible: this.props.items,\n            });\n        }\n        if (!shallowCompareKeys(prevState, this.state)) {\n            this.repartition(false);\n        }\n        var _c = this.state, direction = _c.direction, overflow = _c.overflow, lastOverflowCount = _c.lastOverflowCount;\n        if (\n        // if a resize operation has just completed (transition to NONE)\n        direction === OverflowDirection.NONE &&\n            direction !== prevState.direction &&\n            overflow.length !== lastOverflowCount) {\n            (_b = (_a = this.props).onOverflow) === null || _b === void 0 ? void 0 : _b.call(_a, overflow);\n        }\n    };\n    OverflowList.prototype.render = function () {\n        var _this = this;\n        var _a = this.props, className = _a.className, collapseFrom = _a.collapseFrom, observeParents = _a.observeParents, style = _a.style, _b = _a.tagName, tagName = _b === void 0 ? \"div\" : _b, visibleItemRenderer = _a.visibleItemRenderer;\n        var overflow = this.maybeRenderOverflow();\n        var list = React.createElement(tagName, {\n            className: classNames(Classes.OVERFLOW_LIST, className),\n            style: style,\n        }, collapseFrom === Boundary.START ? overflow : null, this.state.visible.map(visibleItemRenderer), collapseFrom === Boundary.END ? overflow : null, React.createElement(\"div\", { className: Classes.OVERFLOW_LIST_SPACER, ref: function (ref) { return (_this.spacer = ref); } }));\n        return (React.createElement(ResizeSensor, { onResize: this.resize, observeParents: observeParents }, list));\n    };\n    OverflowList.prototype.maybeRenderOverflow = function () {\n        var overflow = this.state.overflow;\n        if (overflow.length === 0) {\n            return null;\n        }\n        return this.props.overflowRenderer(overflow);\n    };\n    OverflowList.prototype.repartition = function (growing) {\n        var _this = this;\n        if (this.spacer == null) {\n            return;\n        }\n        if (growing) {\n            this.setState(function (state) { return ({\n                direction: OverflowDirection.GROW,\n                // store last overflow if this is the beginning of a resize (for check in componentDidUpdate).\n                lastOverflowCount: state.direction === OverflowDirection.NONE ? state.overflow.length : state.lastOverflowCount,\n                overflow: [],\n                visible: _this.props.items,\n            }); });\n        }\n        else if (this.spacer.getBoundingClientRect().width < 0.9) {\n            // spacer has flex-shrink and width 1px so if it's much smaller then we know to shrink\n            this.setState(function (state) {\n                if (state.visible.length <= _this.props.minVisibleItems) {\n                    return null;\n                }\n                var collapseFromStart = _this.props.collapseFrom === Boundary.START;\n                var visible = state.visible.slice();\n                var next = collapseFromStart ? visible.shift() : visible.pop();\n                if (next === undefined) {\n                    return null;\n                }\n                var overflow = collapseFromStart ? __spreadArrays(state.overflow, [next]) : __spreadArrays([next], state.overflow);\n                return {\n                    // set SHRINK mode unless a GROW is already in progress.\n                    // GROW shows all items then shrinks until it settles, so we\n                    // preserve the fact that the original trigger was a GROW.\n                    direction: state.direction === OverflowDirection.NONE ? OverflowDirection.SHRINK : state.direction,\n                    overflow: overflow,\n                    visible: visible,\n                };\n            });\n        }\n        else {\n            // repartition complete!\n            this.setState({ direction: OverflowDirection.NONE });\n        }\n    };\n    OverflowList.displayName = DISPLAYNAME_PREFIX + \".OverflowList\";\n    OverflowList.defaultProps = {\n        collapseFrom: Boundary.START,\n        minVisibleItems: 0,\n    };\n    return OverflowList;\n}(React.Component));\nexport { OverflowList };\n//# sourceMappingURL=overflowList.js.map"]},"metadata":{},"sourceType":"module"}