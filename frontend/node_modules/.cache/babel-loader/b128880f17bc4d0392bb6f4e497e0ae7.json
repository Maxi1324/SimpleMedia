{"ast":null,"code":"/*\n * Copyright 2016 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { Children } from \"react\";\nimport { isElementOfType } from \"../../common/utils\";\nimport { Hotkey } from \"./hotkey\";\nimport { comboMatches, getKeyCombo, parseKeyCombo } from \"./hotkeyParser\";\nimport { hideHotkeysDialogAfterDelay, isHotkeysDialogShowing, showHotkeysDialog } from \"./hotkeysDialog\";\nvar SHOW_DIALOG_KEY = \"?\";\nexport var HotkeyScope;\n\n(function (HotkeyScope) {\n  HotkeyScope[\"LOCAL\"] = \"local\";\n  HotkeyScope[\"GLOBAL\"] = \"global\";\n})(HotkeyScope || (HotkeyScope = {}));\n\nvar HotkeysEvents =\n/** @class */\nfunction () {\n  function HotkeysEvents(scope) {\n    var _this = this;\n\n    this.scope = scope;\n    this.actions = [];\n\n    this.handleKeyDown = function (e) {\n      var combo = getKeyCombo(e);\n\n      var isTextInput = _this.isTextInput(e);\n\n      if (!isTextInput && comboMatches(parseKeyCombo(SHOW_DIALOG_KEY), combo)) {\n        if (isHotkeysDialogShowing()) {\n          hideHotkeysDialogAfterDelay();\n        } else {\n          showHotkeysDialog(_this.actions.map(function (action) {\n            return action.props;\n          }));\n        }\n\n        return;\n      } else if (isHotkeysDialogShowing()) {\n        return;\n      }\n\n      _this.invokeNamedCallbackIfComboRecognized(combo, \"onKeyDown\", e);\n    };\n\n    this.handleKeyUp = function (e) {\n      if (isHotkeysDialogShowing()) {\n        return;\n      }\n\n      _this.invokeNamedCallbackIfComboRecognized(getKeyCombo(e), \"onKeyUp\", e);\n    };\n  }\n\n  HotkeysEvents.prototype.count = function () {\n    return this.actions.length;\n  };\n\n  HotkeysEvents.prototype.clear = function () {\n    this.actions = [];\n  };\n\n  HotkeysEvents.prototype.setHotkeys = function (props) {\n    var _this = this;\n\n    var actions = [];\n    Children.forEach(props.children, function (child) {\n      if (isElementOfType(child, Hotkey) && _this.isScope(child.props)) {\n        actions.push({\n          combo: parseKeyCombo(child.props.combo),\n          props: child.props\n        });\n      }\n    });\n    this.actions = actions;\n  };\n\n  HotkeysEvents.prototype.invokeNamedCallbackIfComboRecognized = function (combo, callbackName, e) {\n    var _a, _b;\n\n    var isTextInput = this.isTextInput(e);\n\n    for (var _i = 0, _c = this.actions; _i < _c.length; _i++) {\n      var action = _c[_i];\n      var shouldIgnore = isTextInput && !action.props.allowInInput || action.props.disabled;\n\n      if (!shouldIgnore && comboMatches(action.combo, combo)) {\n        if (action.props.preventDefault) {\n          e.preventDefault();\n        }\n\n        if (action.props.stopPropagation) {\n          // set a flag just for unit testing. not meant to be referenced in feature work.\n          e.isPropagationStopped = true;\n          e.stopPropagation();\n        }\n\n        (_b = (_a = action.props)[callbackName]) === null || _b === void 0 ? void 0 : _b.call(_a, e);\n      }\n    }\n  };\n\n  HotkeysEvents.prototype.isScope = function (props) {\n    return (props.global ? HotkeyScope.GLOBAL : HotkeyScope.LOCAL) === this.scope;\n  };\n\n  HotkeysEvents.prototype.isTextInput = function (e) {\n    var elem = e.target; // we check these cases for unit testing, but this should not happen\n    // during normal operation\n\n    if (elem == null || elem.closest == null) {\n      return false;\n    }\n\n    var editable = elem.closest(\"input, textarea, [contenteditable=true]\");\n\n    if (editable == null) {\n      return false;\n    } // don't let checkboxes, switches, and radio buttons prevent hotkey behavior\n\n\n    if (editable.tagName.toLowerCase() === \"input\") {\n      var inputType = editable.type;\n\n      if (inputType === \"checkbox\" || inputType === \"radio\") {\n        return false;\n      }\n    } // don't let read-only fields prevent hotkey behavior\n\n\n    if (editable.readOnly) {\n      return false;\n    }\n\n    return true;\n  };\n\n  return HotkeysEvents;\n}();\n\nexport { HotkeysEvents };","map":{"version":3,"sources":["../../../../src/components/hotkeys/hotkeysEvents.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/*\n * Copyright 2016 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { Children } from \"react\";\nimport { isElementOfType } from \"../../common/utils\";\nimport { Hotkey } from \"./hotkey\";\nimport { comboMatches, getKeyCombo, parseKeyCombo } from \"./hotkeyParser\";\nimport { hideHotkeysDialogAfterDelay, isHotkeysDialogShowing, showHotkeysDialog } from \"./hotkeysDialog\";\nvar SHOW_DIALOG_KEY = \"?\";\nexport var HotkeyScope;\n(function (HotkeyScope) {\n    HotkeyScope[\"LOCAL\"] = \"local\";\n    HotkeyScope[\"GLOBAL\"] = \"global\";\n})(HotkeyScope || (HotkeyScope = {}));\nvar HotkeysEvents = /** @class */ (function () {\n    function HotkeysEvents(scope) {\n        var _this = this;\n        this.scope = scope;\n        this.actions = [];\n        this.handleKeyDown = function (e) {\n            var combo = getKeyCombo(e);\n            var isTextInput = _this.isTextInput(e);\n            if (!isTextInput && comboMatches(parseKeyCombo(SHOW_DIALOG_KEY), combo)) {\n                if (isHotkeysDialogShowing()) {\n                    hideHotkeysDialogAfterDelay();\n                }\n                else {\n                    showHotkeysDialog(_this.actions.map(function (action) { return action.props; }));\n                }\n                return;\n            }\n            else if (isHotkeysDialogShowing()) {\n                return;\n            }\n            _this.invokeNamedCallbackIfComboRecognized(combo, \"onKeyDown\", e);\n        };\n        this.handleKeyUp = function (e) {\n            if (isHotkeysDialogShowing()) {\n                return;\n            }\n            _this.invokeNamedCallbackIfComboRecognized(getKeyCombo(e), \"onKeyUp\", e);\n        };\n    }\n    HotkeysEvents.prototype.count = function () {\n        return this.actions.length;\n    };\n    HotkeysEvents.prototype.clear = function () {\n        this.actions = [];\n    };\n    HotkeysEvents.prototype.setHotkeys = function (props) {\n        var _this = this;\n        var actions = [];\n        Children.forEach(props.children, function (child) {\n            if (isElementOfType(child, Hotkey) && _this.isScope(child.props)) {\n                actions.push({\n                    combo: parseKeyCombo(child.props.combo),\n                    props: child.props,\n                });\n            }\n        });\n        this.actions = actions;\n    };\n    HotkeysEvents.prototype.invokeNamedCallbackIfComboRecognized = function (combo, callbackName, e) {\n        var _a, _b;\n        var isTextInput = this.isTextInput(e);\n        for (var _i = 0, _c = this.actions; _i < _c.length; _i++) {\n            var action = _c[_i];\n            var shouldIgnore = (isTextInput && !action.props.allowInInput) || action.props.disabled;\n            if (!shouldIgnore && comboMatches(action.combo, combo)) {\n                if (action.props.preventDefault) {\n                    e.preventDefault();\n                }\n                if (action.props.stopPropagation) {\n                    // set a flag just for unit testing. not meant to be referenced in feature work.\n                    e.isPropagationStopped = true;\n                    e.stopPropagation();\n                }\n                (_b = (_a = action.props)[callbackName]) === null || _b === void 0 ? void 0 : _b.call(_a, e);\n            }\n        }\n    };\n    HotkeysEvents.prototype.isScope = function (props) {\n        return (props.global ? HotkeyScope.GLOBAL : HotkeyScope.LOCAL) === this.scope;\n    };\n    HotkeysEvents.prototype.isTextInput = function (e) {\n        var elem = e.target;\n        // we check these cases for unit testing, but this should not happen\n        // during normal operation\n        if (elem == null || elem.closest == null) {\n            return false;\n        }\n        var editable = elem.closest(\"input, textarea, [contenteditable=true]\");\n        if (editable == null) {\n            return false;\n        }\n        // don't let checkboxes, switches, and radio buttons prevent hotkey behavior\n        if (editable.tagName.toLowerCase() === \"input\") {\n            var inputType = editable.type;\n            if (inputType === \"checkbox\" || inputType === \"radio\") {\n                return false;\n            }\n        }\n        // don't let read-only fields prevent hotkey behavior\n        if (editable.readOnly) {\n            return false;\n        }\n        return true;\n    };\n    return HotkeysEvents;\n}());\nexport { HotkeysEvents };\n//# sourceMappingURL=hotkeysEvents.js.map"]},"metadata":{},"sourceType":"module"}